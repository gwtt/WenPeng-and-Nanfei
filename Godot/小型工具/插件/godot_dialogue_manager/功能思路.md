# 1. 改成按键进行切换下一轮对话

在example_balloon上修改：
原来默认为ui_accept动作
@export var next_action: StringName = &"ui_accept"

# 2. 使用自动对话

### 1. 在对话文本中使用 [next] 标签

在您的对话文件中,只需在对话行末尾添加 `[next=2]` 即可实现等待 2 秒后自动继续 Basic_Dialogue.md:28 :

```
Nathan: 这是第一句话。[next=2]  
Nathan: 两秒后会自动显示这句话。[next=2]  
Nathan: 再过两秒显示这句。  
```

### 2. 使用 auto 自动计算等待时间

如果您想根据文本长度自动计算等待时间,可以使用 `[next=auto]` Basic_Dialogue.md:28 :

```
Nathan: 这句话会根据长度自动计算等待时间。[next=auto]  
```


# 3.动态根据对话调整balloon位置（未能确定有效）

### 1. 传递角色节点映射

在启动对话时,传递一个包含角色名称到节点映射的字典 example_balloon.gd:82-87 :

```GDScript
# 在游戏代码中  
var character_nodes = {  
    "角色A": $CharacterA,  
    "角色B": $CharacterB  
}  
  
var character_themes = {  
    "角色A": preload("res://themes/character_a_theme.tres"),  
    "角色B": preload("res://themes/character_b_theme.tres")  
}  
  
DialogueManager.show_dialogue_balloon_scene(  
    custom_balloon,  
    dialogue_resource,  
    "start",  
    [character_nodes, character_themes]  
)
```

### 2. 在 apply_dialogue_line 中动态调整

在自定义气球脚本中,每次显示新对话行时都会调用 `apply_dialogue_line()` 方法 example_balloon.gd:28-37 。在这个方法中根据角色调整位置和样式 example_balloon.gd:90-128 :

```GDScript
func apply_dialogue_line() -> void:  
    mutation_cooldown.stop()  
      
    # 从 temporary_game_states 获取角色信息  
    # temporary_game_states[0] 是 self  
    var character_nodes = temporary_game_states[1]  
    var character_themes = temporary_game_states[2]  
      
    # 获取当前说话的角色  
    var current_character = dialogue_line.character  
      
    # 根据角色动态定位对话框  
    if character_nodes.has(current_character):  
        var character_node = character_nodes[current_character]  
        var screen_pos = character_node.get_global_transform_with_canvas().origin  
          
        # 将对话框定位在角色上方  
        balloon.global_position = screen_pos + Vector2(0, -150)  
      
    # 应用角色对应的主题样式  
    if character_themes.has(current_character):  
        balloon.theme = character_themes[current_character]  
      
    # 继续正常的对话显示逻辑  
    is_waiting_for_input = false  
    balloon.focus_mode = Control.FOCUS_ALL  
    balloon.grab_focus()  
      
    character_label.visible = not dialogue_line.character.is_empty()  
    character_label.text = tr(dialogue_line.character, "dialogue")  
      
    dialogue_label.hide()  
    dialogue_label.dialogue_line = dialogue_line  
      
    responses_menu.hide()  
    responses_menu.responses = dialogue_line.responses  
      
    balloon.show()  
    will_hide_balloon = false  
      
    dialogue_label.show()  
    if not dialogue_line.text.is_empty():  
        dialogue_label.type_out()  
        await dialogue_label.finished_typing  
      
    # 处理响应或等待输入  
    if dialogue_line.responses.size() > 0:  
        balloon.focus_mode = Control.FOCUS_NONE  
        responses_menu.show()  
    elif dialogue_line.time != "":  
        var time = dialogue_line.text.length() * 0.02 if dialogue_line.time == "auto" else dialogue_line.time.to_float()  
        await get_tree().create_timer(time).timeout  
        next(dialogue_line.next_id)  
    else:  
        is_waiting_for_input = true  
        balloon.focus_mode = Control.FOCUS_ALL  
        balloon.grab_focus()
```

# 4.不利用全局变量属性，直接获取必要属性

这个比较有用，因为滥用全局变量会造成弱解耦。

使用方案是：传递节点/对象数组作为 `extra_game_states` 参数
```GDScript
func pirate():
    print("yarrr")

class GameStateClass:
    var pirate_name = "phil"
    func hello():
        print("ahoy")

func _ready() -> void:
    # GameStateClass.new(), not GameStateClass!
    DialogueManager.show_example_dialogue_balloon(load("res://main.dialogue"), "start", [self, GameStateClass.new()]) 
```

在对话端，您目前无法按名称引用状态本身，但其中的所有函数都应该是功能性的并暴露于上下文中。以下示例脚本在使用上述上下文调用时有效。

```
~ start
do hello()
do pirate()
set pirate_name = "delilah"
do debug(pirate_name)
=> END
```