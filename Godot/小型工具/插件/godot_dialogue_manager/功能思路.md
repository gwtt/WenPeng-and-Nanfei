# 1. 改成按键进行切换下一轮对话

在example_balloon上修改：
原来默认为ui_accept动作
@export var next_action: StringName = &"ui_accept"

# 2. 使用自动对话

### 1. 在对话文本中使用 [next] 标签

在您的对话文件中,只需在对话行末尾添加 `[next=2]` 即可实现等待 2 秒后自动继续 Basic_Dialogue.md:28 :

```
Nathan: 这是第一句话。[next=2]  
Nathan: 两秒后会自动显示这句话。[next=2]  
Nathan: 再过两秒显示这句。  
```

### 2. 使用 auto 自动计算等待时间

如果您想根据文本长度自动计算等待时间,可以使用 `[next=auto]` Basic_Dialogue.md:28 :

```
Nathan: 这句话会根据长度自动计算等待时间。[next=auto]  
```


# 3.动态根据对话调整balloon位置（未能确定有效）

### 1. 传递角色节点映射

在启动对话时,传递一个包含角色名称到节点映射的字典 example_balloon.gd:82-87 :

```GDScript
# 在游戏代码中  
var character_nodes = {  
    "角色A": $CharacterA,  
    "角色B": $CharacterB  
}  
  
var character_themes = {  
    "角色A": preload("res://themes/character_a_theme.tres"),  
    "角色B": preload("res://themes/character_b_theme.tres")  
}  
  
DialogueManager.show_dialogue_balloon_scene(  
    custom_balloon,  
    dialogue_resource,  
    "start",  
    [character_nodes, character_themes]  
)
```

### 2. 在 apply_dialogue_line 中动态调整

在自定义气球脚本中,每次显示新对话行时都会调用 `apply_dialogue_line()` 方法 example_balloon.gd:28-37 。在这个方法中根据角色调整位置和样式 example_balloon.gd:90-128 :

```GDScript
func apply_dialogue_line() -> void:  
    mutation_cooldown.stop()  
      
    # 从 temporary_game_states 获取角色信息  
    # temporary_game_states[0] 是 self  
    var character_nodes = temporary_game_states[1]  
    var character_themes = temporary_game_states[2]  
      
    # 获取当前说话的角色  
    var current_character = dialogue_line.character  
      
    # 根据角色动态定位对话框  
    if character_nodes.has(current_character):  
        var character_node = character_nodes[current_character]  
        var screen_pos = character_node.get_global_transform_with_canvas().origin  
          
        # 将对话框定位在角色上方  
        balloon.global_position = screen_pos + Vector2(0, -150)  
      
    # 应用角色对应的主题样式  
    if character_themes.has(current_character):  
        balloon.theme = character_themes[current_character]  
      
    # 继续正常的对话显示逻辑  
    is_waiting_for_input = false  
    balloon.focus_mode = Control.FOCUS_ALL  
    balloon.grab_focus()  
      
    character_label.visible = not dialogue_line.character.is_empty()  
    character_label.text = tr(dialogue_line.character, "dialogue")  
      
    dialogue_label.hide()  
    dialogue_label.dialogue_line = dialogue_line  
      
    responses_menu.hide()  
    responses_menu.responses = dialogue_line.responses  
      
    balloon.show()  
    will_hide_balloon = false  
      
    dialogue_label.show()  
    if not dialogue_line.text.is_empty():  
        dialogue_label.type_out()  
        await dialogue_label.finished_typing  
      
    # 处理响应或等待输入  
    if dialogue_line.responses.size() > 0:  
        balloon.focus_mode = Control.FOCUS_NONE  
        responses_menu.show()  
    elif dialogue_line.time != "":  
        var time = dialogue_line.text.length() * 0.02 if dialogue_line.time == "auto" else dialogue_line.time.to_float()  
        await get_tree().create_timer(time).timeout  
        next(dialogue_line.next_id)  
    else:  
        is_waiting_for_input = true  
        balloon.focus_mode = Control.FOCUS_ALL  
        balloon.grab_focus()
```

# 4.不利用全局变量属性，直接获取必要属性

> 避免把所有状态塞进单例，提高模块解耦与复用性。

### 4.1 使用思路

• 将**节点 / 对象 / 字典**打包为 `extra_game_states`  
• 调用 `DialogueManager.show_dialogue_balloon()` 时一并传入  
• 在对话脚本里直接调用这些对象或字典中暴露的属性 / 方法

### 4.2 代码示例

#### 1) 传递节点 / 对象

```GDScript
func pirate():
    print("yarrr")

class GameStateClass:
    var pirate_name = "phil"
    func hello():
        print("ahoy")

func _ready() -> void:
    # GameStateClass.new(), not GameStateClass!
	var dialogue_res := load("res://main.dialogue")
    DialogueManager.show_example_dialogue_balloon(
	    dialogue_res, 
	    "start", 
	    [self, GameStateClass.new()]
	) 
```

对应的对话文件：

```
~ start
do hello()
do pirate()
set pirate_name = "delilah"
do debug(pirate_name)
=> END
```

#### 2) 使用 `using` 语句简化引用

```
using player  # player 对象须已作为 extra_game_states 传入

~ start 
Nathan: 你的生命值是 {{health}}。 
Nathan: 你的等级是 {{level}}。
```

#### 3) 直接传递字典

```GDScript
var dialogue_vars = { 
	"player_name": "张三", 
	"gold_count": 100, 
	"level": 5 
} 
DialogueManager.show_dialogue_balloon( 
	dialogue_resource, 
	"start", 
	[dialogue_vars] # ← 仍旧放在 extra_game_states 数组中
)
```

对话文件:

```
Nathan: 你好 {{player_name}}! 
Nathan: 你有 {{gold_count}} 金币。 
Nathan: 你的等级是 {{level}}。
```

### 4.3 变量 / 方法解析优先级

1. `extra_game_states` 数组内的对象（从前到后）
2. 当前场景 (`get_tree().current_scene`)
3. 预先在 Dialogue Manager 里配置的 autoload 快捷方式
4. 全局单例