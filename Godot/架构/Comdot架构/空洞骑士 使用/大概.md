
主要插件：幻影相机、state_charts、AudioManager

目前来说，这个项目只是参考了一部分Comdot的内容，可以只是说只是单纯使用了Component的一部分。

对于空洞骑士，人物有着大量的状态选择，因为只是练习原因，我使用了State Chart插件（回头可以试试行为树或者Limbo AI）配合Component去使用

下面是角色的结构，我将其分为了
CharacterBody2D
- Areas
- Sprite2D
- Animations
- StateChart
- Components

首先不管空洞骑士的怪也好，角色也好，都是由上面组成的。

比如攻击范围，受击范围
比如显示层
比如动画变化
比如状态机



![[Pasted image 20251124204226.png]]


我感觉此套下来是没什么大毛病的。易于使用和修改代码。
下面总结下坑点。

第一

状态的变化。需要知道哪些状态时并行的，哪些状态时单一的。（目前就History State没用过）
比如跳跃和移动就是并行的，但是冲锋时又不能有跳跃和移动。需要考虑好每个状态的逻辑变化关系。复杂情况下，行为树是更好的替代品。
![[Pasted image 20251124204900.png]]
然后对于状态来说，不要分太细，太细容易乱套。比如我之前想把角色的每个技能都要做一个状态，我发现会比较乱，而且增加了大量的代码。平均component没有超过100行代码，我觉得就足够了，无须过度组合，状态和代码维护也乱。

对于一些组件来说，我将玩家的主要数据都放在了一个公共组件上。名称为StatComponent。
比如角色的当前朝向
比如角色的一些共享状态：当前释放技能类型，是否可以冲锋

```GDscript
extends BaseComponent
class_name PlayerStatsComponent

@export var player_data: PlayerData

@export var horizontal_accelerate_speed := 2000.0
@export var max_speed := 120.0
@export var dash_speed := 400.0
@export var gravity := 580
@export var jump_speed := 280
@export var double_jump_speed := 240
@export var jump_higher := 4
@export var state_chart:StateChart
@export var has_black_dash = true

var direction_x: int
var flip_h: bool
var can_dash: bool
var first_jump_over: bool
var can_jump: bool
var can_double_jump: bool
var is_double_jumping: bool
var is_hurting: bool
var skill_type: SkillType

enum SkillType {
	none = 0,
	heal = 1,
	black_wave = 2,
	shout = 3,
	crash_down = 4
}
```
主要的玩家数据都放在PlayerData作为tres持久化，也方便同步UI数据。

关于AnimationTree，我发现是个好东西，可以让一套动作完整执行，比如跳跃到玩家头上加下砸。但是需要额外状态status来进行（是否可以进行进一步优化）。当然，调用变量的时候，需要这样使用，boss_stat_component.is_punch_down，多写了boss_stat_component或者player_stat_component，这边也可以优化下。

比如代码如下

```GDscript
extends BaseComponent
class_name BossPunchDownComponent

@export var bone_spur: PackedScene

enum punch_down_enum {
	PREPARE,
	DO,
	FINISH,
}

var state = punch_down_enum.PREPARE
var punch_down_velocity := 100
var offset_x = 50

func _on_punch_down_state_physics_processing(_delta: float) -> void:
	if state == punch_down_enum.DO:
		owner.velocity.y += punch_down_velocity
		if owner.is_on_floor():
			owner.audio_system.play_audio_2d("表弟落地")
			spawn_bone_spurs()
			state_machine.travel("下戳结束")
			state = punch_down_enum.FINISH
	
	if state == punch_down_enum.FINISH:
		var current_pos := state_machine.get_current_play_position()
		var current_len := state_machine.get_current_length()
		if current_pos >= current_len:
			boss_stat_component.is_punch_down = false
			boss_stat_component.state_chart.send_event("to_idle")
			
func _on_punch_down_state_entered() -> void:
	state = punch_down_enum.PREPARE
	owner.velocity = Vector2.ZERO
	state_machine.start("下戳准备")
	await state_machine.state_finished
	DebugSystem.printHighlight("当前节点:" + state_machine.get_current_node(), self)
	state = punch_down_enum.DO

func spawn_bone_spurs() -> void:
	var temp_offset = Vector2(offset_x, 0)
	var space_state = owner.get_world_2d().direct_space_state
	var check_height = 100.0  # 向上检测的高度
	
	for i in range(10):
		# 左侧位置向上100高度的检测点
		var target_position_left = owner.global_position - temp_offset + Vector2(0, -check_height)
		var query_left = PhysicsPointQueryParameters2D.new()
		query_left.position = target_position_left
		query_left.collision_mask = 1
		query_left.collide_with_areas = true
		query_left.collide_with_bodies = true
		var collision_left = space_state.intersect_point(query_left)
		if collision_left.is_empty():
			SpawnerSystem.spawn_at_direction(bone_spur, owner, -1, -temp_offset)
		
		# 右侧位置向上100高度的检测点
		var target_position_right = owner.global_position + temp_offset + Vector2(0, -check_height)
		var query_right = PhysicsPointQueryParameters2D.new()
		query_right.position = target_position_right
		query_right.collision_mask = 1
		query_right.collide_with_areas = true
		query_right.collide_with_bodies = true
		var collision_right = space_state.intersect_point(query_right)
		if collision_right.is_empty():
			SpawnerSystem.spawn_at_direction(bone_spur, owner, 1, temp_offset)
		
		temp_offset.x += offset_x
		await get_tree().create_timer(0.2).timeout

```

AudioManager是个很有意思的插件，我计划是可以在任意的场景中都可以使用，比如玩家单独使用一个，敌人单独使用一个。可以很方便的管理音效的播放。


AI建议

**函数调用轨道 (Call Method Track)** 在动画文件的末尾添加一个 `Method Call` 轨道，调用组件的 `on_attack_finished()` 函数。这是最精准的，因为它绑定在动画帧上。

